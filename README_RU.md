# Система Аутентификации и Авторизации (RBAC)

## Обзор
Этот проект реализует собственную систему аутентификации и авторизации с использованием FastAPI, PostgreSQL и Redis. Он разработан для демонстрации надежной архитектуры управления доступом на основе ролей (RBAC) без использования "магии" готовых фреймворков.

## Архитектура

### 1. Аутентификация
*   **Механизм:** JWT (JSON Web Tokens).
*   **Поток (Flow):**
    *   Пользователь входит в систему с Email/Паролем.
    *   Сервер проверяет учетные данные (bcrypt) и выдает `Access Token` (короткоживущий) и `Refresh Token` (долгоживущий).
    *   Токены подписаны с использованием `HS256` и секретного ключа.
*   **Выход (Logout):** Реализован через **Blacklist токенов**. Когда пользователь выходит из системы, JTI (уникальный ID токена) сохраняется в Redis до момента истечения срока действия. Любой последующий запрос с этим токеном будет отклонен.

### 2. Авторизация (RBAC)
Система использует гибкую трехуровневую структуру:

1.  **Пользователи (Users):** Стандартные аккаунты с данными профиля.
2.  **Роли (Roles):** Группы прав (например, `admin`, `manager`, `guest`). Пользователь имеет ровно одну роль.
3.  **Правила доступа ролей (Role Access Rules):** Гранулярные права, связывающие **Роль** с **Ресурсом**.

#### Схема Базы Данных
*   **`users`**: Хранит учетные данные (`hashed_password`) и ссылки на `roles.id`.
*   **`roles`**:
    *   `can_read_all` (bool): Глобальный доступ на чтение.
    *   `can_write_all` (bool): Глобальный доступ на запись/администрирование.
*   **`role_access`**:
    *   `role_id`: Ссылка на роль.
    *   `resource`: Строковый идентификатор (например, "orders", "users").
    *   `can_read` (bool)
    *   `can_write` (bool)
    *   `can_delete` (bool)

### 3. Использование и Контроль Доступа
Права проверяются с использованием кастомной зависимости `CheckAccess`.

**Пример:**
```python
@router.get("/orders", dependencies=[Depends(CheckAccess("orders", "read"))])
```
*   Система проверяет Роль пользователя.
*   Проверяет, есть ли у Роли флаг `can_read_all=True`.
*   Если нет, ищет запись в `role_access`, где `resource="orders"`, и проверяет флаг `can_read`.
*   Возвращает `403 Forbidden`, если проверки не пройдены.

## API Эндпоинты

### Аутентификация (Authentication)
*   `POST /auth/register`: Создать аккаунт.
*   `POST /auth/token`: Войти (Получить токены).
*   `POST /auth/refresh`: Обновить Access Token.
*   `POST /auth/logout`: Отозвать токен.

### Пользователь (User)
*   `GET /user/me`: Профиль.
*   `PUT /user/me`: Обновить профиль.
*   `DELETE /user/me`: Мягкое удаление (Деактивация).

### Админ (Управление RBAC)
*   `GET /admin/roles`: Список ролей.
*   `POST /admin/roles`: Создать роль.
*   `POST /admin/roles/{role}/permissions`: Назначить права на ресурс (например, дать роли "manager" права на запись в "orders").

### Мок Бизнес-логики
*   `GET /business/orders`: Защищенный ресурс (Требует права "orders" -> read).

## Стек Технологий
*   **Язык:** Python 3.11+
*   **Фреймворк:** FastAPI
*   **База данных:** PostgreSQL (Async SQLAlchemy)
*   **Кэш:** Redis (для Blacklist)
*   **Контейнеризация:** Docker & Docker Compose

## Начало Работы

### Учетные данные администратора по умолчанию
Для целей тестирования система автоматически создает суперпользователя при запуске:
*   **Email:** `admin@example.com`
*   **Пароль:** `admin123`

### Запуск проекта
1.  Убедитесь, что Docker запущен.
2.  Выполните команду `docker compose up --build`.
3.  Откройте Swagger UI по адресу `http://localhost/api/user-service/docs`.
